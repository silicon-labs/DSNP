= DSNP: Distributed Social Networking Protocol
Dr. Adrian D. Thurston

Copyright (C) 2007-2012 Dr. Adrian D. Thurston

Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby granted, provided that
the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

|==================================
|Protocol Version   | 0.6
|Document Revision  | 11
|Date               | May 19, 2011 
|==================================

DISCLAIMER: This document is draft quality. It is steadily
improving in lockstep with the reference implementation.

[preface]
== Abstract

The social web is emerging as a pervasive communication tool. The systems in
use provide us with online identity and give us tools for efficiently
communicating with people we know. While the emergence of this new paradigm is
to be appreciated, there is a fundamental improvement to be made. The existing
tools force us to consider who we are able to communicate with when we decide
who our communication service provider is. As we collectively discover the
value in the social web, we must lift this constraint. We must go from pockets
of social activity in closed systems, to global social activity over open
protocols. Distributed Social Networking Protocol (DSNP) is one such protocol.
DSNP is a base technology for taking the user experiences of the social web into
an open space were everyone is free to contribute to an ecosystem of software
and techniques. 

== Introduction

Social networking sites have become an important part of our day-to-day
communication. These sites give us a place to declare our identity, an ability
to establish connections with others, and a suite of efficient broadcast
communcation tools.

This is all well and good, save for the fact that the sites we use are closed
systems that do not allow users to cross network boundaries. Our online
identities are fused with the companies that provide us with the software. Our
data is not owned by us. We have little choice and therefore little control. 

For social networking to reach its full potential as a commmunication paradigm,
there must be no boundaries between service providers. Instead, users must be
able to establish connections to others regardless of where they host their
profile. This can be achieved by developing a protocol for social networking
software to use to communicate across the internet. This document describes the
design of one candidate -- Distributed Social Networking Protocol (DSNP).

When we look closely at existing social networking systems we find that
underlying all the features are two basic elements, identity and message
broadcast. When a user takes an action, such as uploading a file or writing a
blog post, they do it with their own identity as the host of the content. At
other times, content is created on a friend's identity. In both cases,
notification of the activity is broadcast to the user's contacts. Once received
by contacts, it can be filtered and displayed appropriately.

In a closed system this is an easy problem to solve. We can have a collection
of users with some internal encoding of identity. User-created content is
encoded in the same database using the same schemas. Displaying broadcasted
information is simply a problem of selecting the appropriate data from the
common database. So long as the system is programmed appropriately, no user can
break the rules by injectng messages to appear as though they come from someone
else. No user can snoop on messages they are not entitled to see.

Once we move to a decentralized system, we gain badly needed freedom, but at
the same time we introduce a number of security issues. How does one stop
people from sniffing activity? How about forging messages? The integrity of our
identity is important to us, and without ground rules and some basic
protections, any proposed system will quickly become unusable. 

In this document we reduce social networking activities to a small number of
basic functions that can be used to construct a familiar social networking user
experience. We do not need to compromise on security or reduce the quality of
the user experience when we break from a central database. We give an overview
of our techniques and we present a software architecture designed for rapid
uptake of these ideas.

=== Properties of DSNP

. Identities are URI-based.

. The system is distributed at the level of identities, as opposed to
collections of identities. Authentication and authorization mechanisms are
based on the credentials of the two users who are interacting. DSNP does not
rely on simply securing the server-server communications with SSL.

. There is a single sign-on. Once a user has signed into her profile, she
is able to get access to her friend's profiles without submitting any password.

. DSNP is secure against forgery by non-friends and friends. It is secure
against eavesdropping by non-friends.

. DSNP allows friendship claims and user activity to be verified by trusted
third parties. False friendships and statements can be claimed easily, but they
can also be discredited easily. This makes it safe for you to evaluate new
friends you don't yet fully trust, without worrying that person will forge
statements by you.

. Security does not rely on DNS or SSL. If ownership of a domain is lost to
an attacker who is able to secure an SSL cert for the domain, the attacker does
not gain control of the identities on the domain.

. DSNP allows unfriending. Once a user is unfriended, they no longer have
access to the user's broadcasts, even if they are somehow able to snoop the
broadcast traffic.

. DSNP allows users to deny messages and trace a leak in the event that a
private statement is shared along with the proof.

=== Security Model

DSNP leverages RSA public key cryptography for identity, the sharing of secrets
and the declaration of relationships. It can be described as a public-key
cryptosystem for web-based identities. Each identity gets a public/private key
pair. The public portion of the key must be fetched over SSL. By requiring SSL
for public key fetches we give some assurance that the correct public key is
always distributed, without introducing the complexities involved with a
web-of-trust, or the cost of commercial certificates on a per-user basis. It is
a trade off, however, as it is possible for a domain to change hands and for
the new owner to start different certs for the identities inside the domain.

Use of SSL makes sense because it is already needed to protect the HTTP
interface to the system. We simply use the same cert to solve the problem of
securely transmitting public keys.

Since public keys are securely exchanged, direct communication between friends
can be protected in the usual asymmetric manner, where a session key is
encrypted using the peer's public key, then content is encrypted using the
session key.

Since users can be expected to have very large friend lists, it is desirable to
omit the use of SSL when delivering messages. DNSP could permit this, without
explicitly identifying the sender or recipient. Only pre-shared relationship
identifiers are transmitted. This identifier has meaning only to the sender and
recipient. A snooper is able to discover that pairs are repeatedly
communicating, but cannot discover who. This is in contrast with schemes such
as PGP or CMS, where senders and recipients are identified in each
communication.

Messages broadcasted to all friends are handled using a pre-shared broadcast
key. This is akin to a long-running session key just for broadcasts. Using a
pre-shared key means that messages do not need to crafted for each recipient.
The message can be computed by the sender, stored once, then a copy sent to
each recipient. If desired, messages can be handed to a third party and
delivered on behalf of the user, without the third party being privy to the
message. Only the sender/recipient domains and the relationship identifiers
(which are chosen randomly) are revealed to the broker. 

When you send messages to your friends, either directly or by broadcast,
messages are signed with your private key. Your contacts can then use your
public key to verify that you wrote the message, uploaded the photo, commented
on someone else's post, etc. Message signatures can also be given to common
friends for verification. This solves the problem of forgery, which is of
practical concern for individuals with reputations to preserve among their peer
groups, especially as peer groups grow. Of course, one loses deniability when
messages are signed, but if deniability is needed, social networking is
probably the wrong communication medium.

Your list of friends can be treated as private information. It is impossible
for someone to probe your list of friends if you don't want to publish it. The
list must be explicitly granted, even to current friends (see next point for a
minor exception). This makes it possible to partition your relationships into
different groups, such as family, close friends, co-workers, and people you
hardly know but might like to get to know better.

=== Definitions

* Content-Manager: Software that a user, and user's connections interact with.
This software provides the 'front' for the user's identity. At a minimum, this
should be a web-based application, though other forms of content-manager are
possible.

== Short Paper

=== RSA-Based Identity

If we consider the Pretty Good Privacy system (PGP) as a social network, one
function it does really well is declare and protect identities. Each identity
gets an RSA asymmetric key. It is used as the foundation of the identity. In
DSNP we do the same; we allocate key pairs, distribute public keys, and use the
key pairs for signing and encryption. We take out the email address from the
public portion and put in a user's URI.

We take a different approach to managing private keys. It is unlikely that we
can expect an average user to manage their own keys, so we store keys on the
server. This is something of a security risk that we must mitigate. We utilize
not a single private key, but several keys, with varing privilege levels. 

The most secure key is allocated at identity creation time, encrypted with a
password, and decrypted for use very infrequently. It is reserved for proving intent
of significant operations, such as identity movement or deletion.

Then next most secure key is stored encrypted, is decrypted on login, but is
immediately discarded from memory after use. It can be used to sign login
tokens that prove recent login activity. 

The third most secure key is stored encrypted and retained in memory
unencrypted, but only while the user is logged in. It is used for any signing
activity that requires a currently logged-in user. This key is required most
often, as much of the protocol covers activity of logged-in users.

The final key, which is the least secure, is stored unencrypted and is always
available for use, regardless of whether the user is logged in or not. This is
used for activity that does not require a logged in user. It is typically in
response to other user's queries or requests, for example, submitted friend
requests.

If we know our peers will accept signatures at certain privilege levels for
certain actions, and we are diligent about encrypted storage, we protect
ourselves from some forms of unauthorized access to our identity. For example,
we can anticipate recovering from a server theft under this scheme. The most
secure key won't be accessible by anyone who has acquired the server
hardware, even if they manage to keep it running during the theft. Assuming
adequate backups are available, the identity can then be safely moved to
another site by notifying all contacts of the change.

We use asymmetric keys to protect identities, encrypt messages, sign messages.
Next we need to build out a protocol that supports friending, passwordless
login, message passing, distributed agreement.

=== Friending Protocol

The first step in a social network interaction is to establish contacts. We
have three computers involved int this action: the browser initiating the
request, the server representing the browser's identity, and the server
representing the recipient of the friend request.

It is critical that the recipient's server be assured the browser is the
actual owner of the identity they are claiming. To satisfy this we must
challenge the browser to return a token that only the browser's server is privy
to. The browser must go home to their own server to retrieve this token, then
submit it as part of the final friend request. Once the request is received, it
is stored on the recipient's server to later be accepted or denied. This final
step involves a notification message to the requestor.

This challenge-response pattern is repeated throughout DSNP. We often have some
browser on another user's site and the browser needs to prove ownership of
their identity. A token is encrypted to the identity's appropriate RSA key, the
browser goes home, and if logged in correctly, fetches the token and returns it
to the site that issued the challenge.

=== Passwordless Login

The pattern used for friending is also used for passwordless login. If a user
wishes to login to a friend's site, a login token is allocated and encrypted to
the browser's identity. The browser must go home, prove she is logged in,
decrypt the token, then return it to the friend's site. From there the browser
is granted access the identity in a role that indicates she is a friend.

=== Broadcasting

The basic element in social networking is the broadcasted message. All activity
by a person is broadacasted to others, then displayed in an aggregate news
feed. These feeds are filtered and restricted by the recipient's viewing
preferences.

Considering a user's contact list can grow to a large number of recipients,
perhaps on the order of thousands, we must consider the cost of RSA-based
encryption to contact lists of this size. Several thousand RSA-based
encryptions can easily take up seconds of CPU time. If we wish to develop
systems that host thousands of users, we are creating for ourselves a
performance problem.

To solve this problem, DSNP introduces a broadcast key. This is a pre-shared
symmetric key that is given to contacts ahead of time. All broadcast activity
can be encrypted once and the single message copied to all contacts. The key has
a generation associated with it, so if it needs to be replaced because a group
member is being removed, it can be delivered one user at a time, then the new
generation made active once it has been fully replaced.

=== Message Signing Keys

Broadcast and direct friend-to-friend messages must be signed to prove they
come from a valid contact. Signing is both good and bad. It is good because it
eliminates the possibility of attackers injecting messages into our news feed. It
is bad because we give people proof that we have said something. While not
expected and always unfortunate, we have to consider the possibility that
something we say can be used against us. We must introduce some deniability.

To solve this, we never sign the things we say with our permanent identity
keys, instead we distribute signing keys and use those. Signing keys are less
valuable to us and can be revealed should we absolutely need to deny something
we have said. We can do this while preserving our most valuable keys and
therefore preserve our identity.

Signing keys are given directly to every contact. We compose a unique message
that contains the recipient's identity and the public portion of the disposable
signing key, then sign that message with one of our permanent keys. If someone
makes public something we have said and they wish to prove it, they must also
reveal their own identity along with the proof. 

Next, we are able to divulge the signing key and create a situation such that
anyone is able to produce the proof that the attacker produced. Once a key has
been revealed, the attacker then faces the problem of proving that the signed
message they received was produced before the key was revealed. This is
difficult because it is easy to cast doubt on any such assertion.

Before we reveal a signing key, we must first inform all of our remaining
friendly contacts that the key is no longer good, otherwise those contacts may
receive forged messages and believe them. We therefore have to track who we
have given signing keys to. This applies to friends, and friends of friends who
have received notifications of our activity.

Key revealing should be considered a last line of defense, as it is indeed
cumbersome to ensure that a signing key is no longer trusted by the contacts
who have previously received it. It is a nice option to have, nonetheless.

=== Remote Broadcasting

Many social social activities can be considered messages with several actors.
For example, a "board post" is a hosted message with a publisher and an author.
The publisher is the owner of the board and the author is the friend making the
post. Notification of the post is broadcast to the contact list of both
parties.

As another example, a photo tag is a message containing co-ordinates and a
reference to a hosted photo. It can involve up to three actors. The publisher
is the owner of the photo. The subject is the person being tagged, and the
author is the person doing the tagging.

In DSNP we generalize multi party activity into a function called 'remote
broadcasting' and we propose reducing social activity to this function. The
kinds actors that can be involved are the publisher, the author, and some
number of subjects. Any of the actors are able to broadcast the message to
their contact list, and when they do so, they are also called a broadcaster.

We require all actors to agree on every remotely broadcasted message. On some
message types we want the actor to be logged in to authorize the message, and
on others, the message can be automatically authorized. Authors should always
be logged in. For the remaining combinations of message type and actor type,
these decisions can be based on each user's preferences. For example, a user
can deny a signing request on a photo tag until they have had a chance to
review the tag, or they can automatically accept all photo tags by certain
users. Regardless of the particular policy in place, once agreement has been
reached by all parties, the message can be broadcast.

Like the friending protocol and passwordless login, remote broadcasting
involves a challenge and response to the author. For example, a "board post"
requires that the browser prove they are in control of the author identity and
intend to compose the message. They most go home to obtain the challenge
response. This also gives them the opportunity to register the composition of
the message and produce the signature that will be distributed to others.

=== Software Architecture

It is clear that new protocols for social networking are needed. Proliferating
an implementation of a new protocol is a daunting task. There is no canonical
language of the web. We have Ruby, Python, Perl, PHP, and many other languages
that are used to write the supporting frameworks. We cannot favour any single
language or framework. 

For the federated social web to flourish, we need web-based systems that
communicate asynchronously. There will be encryption involved. There will be a
desire for carefully engineered systems that support high-volume, low-latency
message processing. It is therefore natural to move protocol implementation
into a long-running daemon, separating the user interface from protocol
implementation details in a language-agnostic way.

The reference DSNP implementation has been developed this way. It is separated
into a content manager, which provides the web-based UI, and a daemon that
deals with the protocol specifics. The daemon is reusable by other systems. It
is is responsible for server-server communication, but also serves the
web-based content managers.

The content manager is responsible for providing all aspects of the user
experience. It can be written much the same way non-distributed social
networking systems are written. It should be designed to support a collection
of users and contain numerous functions for managing content. How it should
differ from existing systems is that it must defer to the daemon for all
communication between identities. If it follows the protocol, as implemented by
the daemon, identities can communicate not only with other users on the same
site, but with users on other sites, including those running software written
by other people.

==== User Representation

In DSNP a user is identified by her IDURI. This is a URI with scheme
`dsnp`, followed by a host and path, and optional arguments. Since this is
an arbitrary URI, we allow any user identification plan (eg `?uid=N`, or
`/user.name/`). When an IDURI is written using the `https` scheme it
is called an IDURL and it is expected to be accessible from a web browser. 

==== Command/Notification

The DSNP daemon exports a set of commands for content managers to use and makes
them available over a local socket. It expected that the content manager will
make available a program that the DSNP daemon can use to notify the content
manager of various events, such as message arrival, or friend acceptance. Both
of these languages are text-based and are designed to be easily constructed and
parsed from common web application languages.

The relid request is an example of a command for use by content-managers. This
is the command that should be called when a friend request is received. It
begins the friend request process.

----
"RELID_REQUEST" SP
        user-iduri SP 
        friend-iduri CRLF
----

The DSNP daemon responds with a request identifier. The content manager then
redirects the browser to their home identity where the identifier is submitted
using a command similar to this one (relid-response).

When the DSNP daemon has something it needs to tell the content manager about,
such as a friend request being accepted, it uses the notification interface. It
will fork and execute a program that is owned by the content manager and send
it the notification using a syntax similar to the above. The following is the
syntax for the friend-request-accepted notification.

----
"FRIEND_REQUEST_ACCEPTED" SP 
        user-iduri SP 
        friend-iduri SP
        accept-reqid CRLF
----

The content manager can then register in its database that the event occured
and appropriately notify the user.

==== Standard HTTP Args

DSNP requires that browsers be redirected from site to site. Redirection is
necessary in the friending, passwordless login, as well as remote broadcasting
portions of the protocol. To ensure interoperability, DSNP prescribes a set of
standard HTTP args that must be added to IDURIs to indicate certain functions,
or to provide associated information. The following is an example of the
arguments added to the destination identity URI when the browser is sent home
in the second step of the friend process.

----
    addArgs( $destIduri,
        "dsnp=relid_response",
        "dsnp_iduri=$userIduri",
        "dsnp_reqid=$reqid"
    )
----

==== Implementation

Most of the ideas the ideas expressed in this paper are implemented in the
reference implementations. The reference daemon is called DSNPd and the content
manager is called Choice Social. The protocol is described in the DSNP
specification, all of which are available from the DSNP home page.

----
http://www.complang.org/dsnp/
----

This protocol is still being developed and is expected to change. The intent is
to continuously maintain a working reference implementation. As of this
writing, the protocol is at version 0.6.

=== About the Author

Adrian D. Thurston holds a Ph.D. in Computer Science from Queen's University,
where he studied and developed source transformation systems. Adrian is the
author of Ragel, a unique software development tool for producing very fast
parsers. He works in the field of network security where he designs and
develops real-time parsing systems that analyse network traffic for evidence of
security events.

== Packets

There are ten messages for carrying encryption parameters, encrypted data, and
various other atoms of the protocol. These messages most often carry binary
payloads. They are often encrypted and used in the construction of other
packets. As a general rule, encryption packets do not carry any sender or
recipient information. Senders and recipients are transmitted in the container
message.

The basic element of the encryption packet is the binary string. It is composed
of a 16bit length in network byte order, then the binary data. Many of the
packet components are expected to contain other packets. The length-data idiom
still applies here. The data can be treated as an opaque binary string that is
then reparsed as some other packet.

----
    len16   = octet octet
    bin16   = len16 *octet
----

[[public-key-packet]]
=== Public Key

The public-key packet is used for transmitting a user's public key. The key
contains `n` and `e` BIGNUM components, encoded in big-endian binary
format. 

----
    n           = bin16
    e           = bin16
    public-key  = %x01 n e
----

[[public-key-set]]
=== Public Key Set

The Public Key Set packages up the four public keys at privilege levels 0 to 3.
Privilege level 0 is the most trusted. The public key set is delivered in a
<<signed-packet,signed packet>>, with the signature verifiable by the
privilege 0 key.

----
    priv0           = bin16
    priv1           = bin16
    priv2           = bin16
    priv3           = bin16
    public-key-set  = %x02 priv0 priv1 priv2 priv3
----

=== Relid Set

The Relid Set is used to package up a collection of relationship IDs that are
used to identify one direction of a relationship. The four relids correspond to
the four privilege levels. All four relids identify the same relationship. A
user messages another user at a specific privilege level by choosing the
appropriate relid corresponding to the protection desired.

----
    priv0      = bin16
    priv1      = bin16
    priv2      = bin16
    priv3      = bin16
    relid-set  = %x03 priv0 priv1 priv2 priv3
----

=== Relid Set Pair

The Relid Set Pair packages up two sets of relationship IDs. This packet is
used in the friendship request process. It is useful for storage of the
relationship IDs. Also, it is returned by the requestor and serves two
purposes, to answer to the encryption challenge, and to return the friendship
requestor's relationship IDs.

----
    requested       = len16 relid-set
    returned        = len16 relid-set
    relid-set-pair  = %x04 requested returned
----

=== Relid Response

The relid response is the packet that the friendship requestor returns to the
responder. It contains a request ID and the pair of relid sets. The request ID
is used to identify the friendship request in the accept/deny process. The
relid set pair contains the set of relids generated by the responder and the
set returned by the requestor.

----
    peer-notify-reqid  = bin16
    rr-relid-set-pair  = len16 relid-set-pair
    relid-response     = %x05 peer-notify-reqid rr-relid-set-pair
----

=== Private Key

Private keys are never transmitted, but they must be stored and backed up
(encrypted). This packet type specifies the format of the private key before it
is encapsulated in a protection envelope.

----
    n            = bin16
    e            = bin16
    d            = bin16
    p            = bin16
    q            = bin16
    dmp1         = bin16
    dmq1         = bin16
    iqmp         = bin16
    private-key  = %x06 n e d p q dmp1 dmq1 iqmp
----

=== PW Encrypted

This packet contains data encrypted with the owning user's password. The
password is hashed (SHA1) and used as the RC4 key (note RC4 is temporary).

----
    pw-enc-message  = len16 SYM-ENC( plain-message ) 
    pw-encrypted = %x07 pw-enc-message
----

[[signed-packet]]
=== Signed

This packet contains plaintext data that is accompanied by a signature. Unless
specified otherwise, the signature is acquired by applying RSA-sign to the
plaintext. 

In the BK Signed Encrypted and the Signed Encrypted messages the
signature is acquired by concatenating either the broadcast key or the
recipient's public key with the plaintext then applying RSA-sign to that. The
plain message component excludes the keys.

----
    sig            = bin16
    plain-message  = bin16
    signed         = %x08 sig plain-message
----

=== Signed Id

----
    signed-id = %x09 iduri %x00 bin16 bin16
----

=== Detached Sig

----
    detached-sig = %x0a bin16
----

=== Detached Sig Key

----
    detached-sig-key = %x0b bin16 bin16
----

=== Signed Encrypted

The signed-encrypted message contains data that is signed with a public RSA
key, and encrypted with a symmetric key that is included in the message and
protected by the RSA public key. It has two components: the RSA-protected key,
and the symmetric-key protected RSA signature and message. The RSA sig and the
message body are encrypted using the symmetric key as a single stream. The
signature is produced by concatenating the
<<public-key-packet,public key packet>> and the message body, then RSA-signing the resulting
block. SHA1 is used as the signing hash. RC4 is used as the stream cipher
(temporary).

----
    protected-key     = len16 PK-ENC( sym-key )

    enc-message       = len16 SYM-ENC( signed )

    signed-encrypted  = %x0c protected-key enc-message
----

=== BK Keys

----
    bk-keys = %x0d bin16 bin16
----

=== BK Encrypted

----
    enc-message       = len16 SYM-ENC( signed )

    bk-encrypted      = %x0e enc-message
----


=== BK Signed Encrypted

The bk-signed-encrypted message contains data that is signed with a public RSA
key and encrypted with a pre-shared symmetric key. The encrypted data block
contains two components: the signature and the message data. Both are encrypted
as a single stream. The signature is produced by concatenating the broadcast
key with the message data, then signing the resulting block. SHA1 is used as
the signing hash. RC4 is used as the stream cipher (temporary).

----
    enc-message          = len16 SYM-ENC( signed ) 

    bk-signed-encrypted  = %x0f enc-message
----

=== Broadcast

----
    publisher       = %x01
    author          = %x02
    subject         = %x03
    body            = %x04
    broadcast-type  = %x10

    iduri           = bin16
    sig             = bin16 

    broadcast =
            broadcast-type
            [ publisher iduri sig ]
            [ author iduri sig ]
            *( subject iduri sig )
            body 
            bin16 
----

=== Recipient List

----
    recipient-list  = 
            %x11 *( relid %x00 iduri %x00 ) %x00
----


%
% Section: Protocol
%

== Protocol

DSNP has both text and binary elements. Communcation between DSNPd and content
managers are in a textual format. This covers commands and notifications.
Daemon-daemon communication and exportable packets are in a binary format.

The textual commands and notifications all have the same general structure.
They consist of a command or notificaiton name, a list of arguments, CRLF, and
an optional message body. If there is a message body, the last argument will be
the number of bytes in the message body. Message bodies can be arbitrary data,
and should be parsed separately from the message. A CRLF follows the message
body.

The binary packets and commands use a single byte to indicate the type of
element, followed by any number of arguments. Arguments are generally a
fixed-width atom, a null-terminated string, or binary data in length-body
format.

=== Timeouts

A DSNP implementation should close connections after a time of inactivity. The
DSNP daemon times out connections after 7 seconds, both when reading and
writing. The user agent times out connections to the daemon after 12 seconds.

=== Modified Base64

Throughout DSNP a modified Base64 encoding is used for binary data. The
characters `-` and `_` are used in place of `+` and `/` for
the 63rd and 64th characters. This modified encoding is commonly used in
applications where Base64 data must be embedded in URLs. Note that we omit
trailing padding, which is normally specified using the `=` character.

----
    base64-chars  = %x41-5A / %x61-7A / %x30-39 / "-" / "_"

    base64        = 1*( base64-chars )
    
    message-id    = 1*( base64-chars / "+" "." )
----

=== Iduri and Site

----
    dist-name    = base64

    # FIXME: - not ABNF
    path-part    = 1*( graph - "/" )

    rel_path     = *( path_part "/" ) [ path_part ];

    path         = "/" rel_path

    iduri        = "dsnp://" path-part "/" rel_path

    site         = iduri

    key          = base64
----

=== Passwords

----
    pass = 1*( ::graph:: )
----

=== Connection Negotiation

The DSNP command is the initial command that must be sent by all clients. In
this command, the client sends the DSNP versions it is willing to talk and the
and the connection authentication method.

The auth method can be either a local connection, or a TLS-secured connection.
Local connections require a secret key, which is typically stored on disk on
the server. Local connections must pass through the loopback network interface
(be bound to 127.0.0.1). Local connections that do not should be rejected.

If it is a TLS-secured connection, the server must supply a valid certificate
that matches the requested hostname. The server responds with OK followed by
the version it has chosen from the list. `"OK" SP version EOL`. This
should be the highest supplied version it supports.

----
    SP           = %x20
    EOL          = [ %x0D ] %x0A

    auth = 
        "local" SP key /
        "start_tls" SP host

    version = '0.6'

    supported-versions = version *( "|" version )

    connection-negotation = 
        "DSNP" SP supported-versions SP auth EOL
----

=== Creating Users

A user name and password is requested. The user's IDURI is assigned. It
consists of the scheme `dsnp://`, the site's root name, and the user name
as the final path component. It must end with a slash. Similarly, the user's
IDURL is assigned. This is identical, except the scheme is `https://`.

%
% IDURI: dsnp://www.foo.com/site/gia/ 
% IDURL: https://www.foo.com/site/gia/
%

Four RSA key pairs are created. The keys have privilege levels 3 to 0.
Privilege level 3 is considered the weakest. Privilege level 0 is reserved for
the most significant actions, such as profile moving.

* Priv 3: Not password protected. For activity that doesn't require the user be logged
in.

* Priv 2: Password protected, decrypted in memory only while user is logged
in. A sig indicates the user is currently logged in. Used for activity by
logged in user.

* Priv 1: Password protected. Purged from memory immediately after it is
used. Decrypted on each login. A signed timestamp by this key indicates the
user logged in with her password at that time.

* Priv 0: Password protected. Purged from memory immediately after use.
Decrypted on demand. A message signed by this key indicates the user submitted
her password to produce the signature. This privilege ring is reserved for
moving and deleting the identity.

The public portions of the keys are <<public-key-command,made available>>.
The key must always be fetched using SSL. This
guarantees that a key has been provided by the server hosting the identity and
has not been altered.

==== New User

----
    local-new-user = 
            "NEW_USER" SP
            user SP 
            pass EOL
----

The context is a local connection. This command returns `"OK"` followed by
`EOL`.

=== Owner Login

To login, the user agent submits credentials to the LOGIN command. key that
will be used to verify with the server that the user is logged in when commands
are issued (not yet added to the protocol).

==== Login

The session ID is a string that is used to associate the granted login token
with the session ID of the browser. It is supplied to the user agent when DSNPd
needs to specify to the user agent that the browser's login token has expired.

----
    local-login = 
            "LOGIN" 
            user SP 
            pass SP 
            session-id EOL
----

This command is for local connections only. On success, the login commands
returns the owner's URI hash, a login token, and the number of seconds the
token is valid for. The URI hash can be computed independently, but is returned
here for convenience. `"OK" SP hash SP token SP lasts EOL`.

[[public-key-command]]
==== Public Key

The Public Key command is for fetching a user's public key. A public key must
never change. If a peer detects a change, the user must be considered invalid.
The message returned is a <<signed-packet,signed packet>>, that
contains a <<public-key-set,public key set>>. The priv0 key is used
for signing.

----
    public-key = %x32 user %x00
----

This command is for TLS connections only. It returns `%x bin16`.

=== Friendship Request

The purpose of the friendship request is to establish a connection between two
users. A remote user to indicates to a local user that she wishes to establish
a connection. During this exchange, the two sites securely exchange random
identifiers that will be used by the two parties to identify the relationship,
should it proceed.

It is important that the user who is receiving the friend request be assured
that the person controlling the browser is the actual owner of the identity
submitted. To guarantee this, we must send the browser home, where it can
answer to a challenge to decrypt a randomly selected token. The browser then
sends the token back. When the token is sent back a similar challenge is issued
to ensure the person making the friend request indeed has the right identity.

There are two other parts of the DSNP protocol that have this flavour:
cross-site login and remote publishing both issue a challenge and require the
browser to go home, fetch the answer, then return it. In the course of this all
three parties, browser, the browser's server and the friend's server, are
assured they are dealing with who they think they are.

The person requesting friendship is the referred to as the requestor, with
identity requestor-iduri. The person who is receiving the request is the responder, with
identity responder-iduri

. The requestor fills in a friend request form at resp-iduri
        .. requestor answers a challenge, which can be a CAPTCHA, or 
            personalized question
    .. requestor submits requestor-iduri
    
. The responder's server processes the request:
        .. verifies challenge response
    .. fetches the public key for requestor-iduri (using SSL)
    .. randomly generates a set of one-way relationship ids (requested-relid-set)
    .. randomly generates a one-way request id (requested-reqid)
    .. encrypts the relationship ids to requestor and signs it
    .. makes message available to be fetched using requested-reqid to identify it
    .. redirects the requestor's browser home to requestor-iduri, calling the return-relid 
        function with resp-iduri and requested-reqid as arguments
    
. Requestor's server processes the return-relid call:
        .. verifies browser is logged in as the owner of requestor-iduri
    .. fetches public key for resp-iduri (using SSL)
    .. fetches encrypted requested-relid-set from resp-iduri using requested-reqid
    .. decrypts and verifies requested-relid-set
    .. randomly generates returned-relid-set
    .. randomly generates returned-reqid
    .. encrypts (requested-relid-set,returned-relid-set) to responder and signs it
    .. makes message available to be fetched using returned-reqid to identify it
    .. redirects the friender back to responder-iduri, where the friend-final function is called
    with requestor-iduri and returned-reqid as arguments.
    
. Responder's processes the friend-final call:
        .. fetches encrypted (requested-relid-set,returned-relid-set) from requestor-iduri using returned-reqid
    .. decrypts and verifies message, must contain correct requested-relid-set
    .. stores request for friendee to accept/deny
    
There are five commands related to friendship request. The first three are the
commands used by the user agent on behalf of the browser for the three major
steps. The last two are commands used by DSNPd to fetch the encrypted the
relids.

==== Relid Request

The relid request is issued by the responder's server on behalf of the
requestor. The server generates a relationship ID and makes it available for
the requestor's server to fetch. It then redirects the user back home where the
request can be processed.

----
    relid-request =
            "RELID_REQUEST" SP
            user SP 
            iduri EOL

    returns: OK reqid EOL
    context: local connection
----


==== Relid Response

The relid response is executed by the requestor. The requestor must be logged
in for this command to run. The requestor's server fetches the request from the
responder's server, decrypts and verifies it. It then generates a response and
makes it available for the responder's server to fetch in the final step.

----
    relid-response = 
            "RELID_RESPONSE" SP
            login_token SP
            reqid SP
            iduri EOL

    returns: OK reqid EOL
    context: local connection
----


==== Friend Final

The final step in the friend request protocol is for the responder's server to
verify the response, which includes a copy of the request it generated in the
first step. If the response validates, a friend request is stored for the
responder user to accept or deny.

----
    friend-final =
            "FRIEND_FINAL" SP
            user SP
            reqid SP
            iduri EOL

    returns: OK EOL
    context: local connection
----


==== Fetch Requested Relid

----
    fetch-requested-relid = 
            %x33
            reqid %x00

    returns: OK message EOL
    context: TLS connection
----


==== Fetch Response Relid

----
    fetch-response-relid =
            %x34
            reqid %x00

    returns: OK message EOL
    context: TLS connection
----


=== Friendship Accept and Deny

The next time the friendee logs in they are presented with the friendship
request. They can either accept or deny the request. 

The acceptor sends accept notification with both relids. They are sent back
indicating that the friendship was registered on the other end. The acceptor
then registers the friendship and sends a registered message. It can can now
send broadcast key and broadcast tree insertion messages. The other end can
send these messages after it receives the registered message.

==== Accept Friend

Accept friend is issued by the responder. The particular friend request is
identified by reqid, which is the request ID originally allocated by the
responder in the relid request command. The responder must be logged in.

----
    accept-friend =
            "ACCEPT_FRIEND" SP
            login_token SP
            reqid EOL

    returns: OK EOL
    context: local connection
----


==== Notify Accept, Registered

During the friend accept exchange, these messages arrive as the payload to
standard messages. They are identified as prefriend messages by the state of
the relationship. Notify accept is used to indicate to the requestor that the
receiver intends to accept the friendship request. If the requestor still
considers the request valid, it indicates so and registers the friendship. The
friendee then registers the friendship and sends the REGISTERED message to
indicate that the process is now complete, and friend-friend messages can be
sent. This is how the friender knows it is safe to begin sending messages and
otherwise broadcast information.

----
    notify-accept = 
            %x01 
            peer-notify-reqid

    returns: OK EOL
    context: prefriend message
----


----
    registered = 
            %x02 
            peer-notify-reqid 
            friend-claim-sig-key

    returns: OK EOL
    context: prefriend message
----


=== Login as a Friend

Once a user is logged in to her page, she is able to login to her friend's
pages without submitting any credentials. The friend's site requests that she
go to her own page to fetch the answer to a crypto challenge that is posed
directly to her identity. At her own site it is verified that she is is the
owner, and the login token is returned to the friend's site. Note that this
pattern is identical to friendship request, and is repeated throughout DSNP.

The user wishing to login to the friend's site is referred to as the requestor,
and she is identified as requestor-iduri. The relid she uses to identify the relationship
we call the QURI-RELID, and will be the one she was given during the friendship
request process. The friend who's page is being logged into will be called the
responder, and her identity is responder-iduri.

. The requestor visits responder-iduri/login-as-friend
        .. submits as the only argument a hash of requestor-iduri
    
. The responder's server processes the request
        .. verifies that hash(requestor-iduri) is a friend
    .. randomly generates a reqid and login token
    .. encrypts the token to the user and signs it
    .. makes it available to be fetched with reqid as identifier
    .. redirects user to requestor-iduri/return-token with hash(requestor-iduri) and reqid as
            arguments
    
. The requestor's server verifies the browser is the identity owner
        .. checks that hash(responder-iduri) is a friend
    .. if browser is not logged in, fails the process
            (sending the user to a login page encourages phishing)
    .. fetches the token using from responder-iduri using reqid to identify it
    .. decrypts and verifies the token
    .. redirects the browser to responder-iduri/submit-ftoken with requestor-iduri 
    and the token as arguments
    
. Friend login final
        .. verifies that token is valid for requestor-iduri.
    .. grants friend credentials to the browser for the session.
    
There are four commands related to friend login. The first three are used by
the content-manager on behalf of the user in the primary challenge-response
scheme. The fourth is used by the friend logging in to fetch the encrypted
challenge.

==== Ftoken Request

----
    ftoken-request = 
            "FTOKEN_REQUEST" SP 
            user SP 
            hash EOL 

    returns: OK iduri hash reqid EOL
    context: local connection
----


==== Ftoken Response

The Ftoken Response command is executed by the requestor's user agent. It is
responsible for supplying the proof that the browser owns the identity that is
logging it. This command requires users be logged in.

----
    ftoken-response = 
            "FTOKEN_RESPONSE" SP 
            login-token SP 
            hash SP 
            reqid EOL 

    returns: OK iduri token EOL
    context: local connection
----


==== Submit Ftoken

The session ID is a string that the user agent submits to identify the browser
session that the login is for. This session id may be used later by DSNPd to
invalidate the login.

----
    submit-ftoken = 
            "SUBMIT_FTOKEN" SP 
            token SP 
            session-id EOL 

    returns: OK iduri hash lasts EOL
    context: local connection
----


==== Fetch Ftoken

----
    fetch-ftoken = 
            %x35
            reqid %x00

    returns: OK message EOL
    context: TLS connection
----
    
=== Messages to Friends

Sending friend-friend messages that are encrypted to the recipient and signed
by the sender. 

==== Submit Message

----
    submit-message = 
            "SUBMIT_MESSAGE" SP 
            login-token SP
            iduri SP 
            length EOL message EOL

    returns: OK EOL
    context: local connection
----


==== Message

The message command is used to deliver prefriend messages and friend messages.
The type of message accepted is determined by the state of the friendship
request. The privilege level of the message is determined by the privilege
level relationship ID used to identify the message.

----
    message =
            %x36 
            relid %x00
            bin16 

    returns: message dependent (see below)
    context: TLS connection
----


==== Fof Message

----
    fof-message =
            %x37 
            relid %x00 
            bin16

    returns: message dependent (see below)
    context: TLS connection
----


=== Broadcasting to a Group

As previously mentioned, DSNP uses a broadcast key for the sending of messages
to groups. The key has an ID and a generation. The ID is a base64 encoded
random string assigned by the owner and used by the recipients to identify the
group within the sender's collection of groups.

==== Submit Broadcast

----
    submit-broadcast = 
            "SUBMIT_BROADCAST" SP 
            login-token SP 
            length EOL message EOL

    returns: OK EOL
    context: local connection
----


==== Broadcast Key

----
    broadcast-key = 
            %x01 
            dist-name %x00 
            generation64 
            bin64

    returns: OK EOL
    context: user-user message
----


==== Broadcast Recipient

----
    broadcast-recipient = 
            %x38
            relid %x00

    returns: OK EOL
    context: TLS connection
----


==== Broadcast

----
    broadcast = 
            %x39 
            dist-name %x00
            generation64
            bin16

    returns: message dependent
    context: TLS connection
----

=== Remote Broadcasting

Remote broadcasting (or remote publishing) covers activity that a user makes on
a friend's site, such as commenting on a photo or, writing a public message on
a user's message board. This activity has to be authorized by both the author
of the message and the subject. It must be encrypted and signed by both parties
to prove to the message was not forged, and to ensure that only common friends
are able to view such messages. The encryption requirement may be relaxed to
allow others outside of the common friend group to view messages.

==== Remote Broadcast Request

----
    remote-broadcast-request = 
            "REMOTE_BROADCAST_REQUEST" SP
            flogin-token SP
            length EOL message EOL

    returns: OK reqid EOL
    context: local connection
----


==== Remote Broadcast Response

----
    remote-broadcast-response =
            "REMOTE_BROADCAST_RESPONSE" SP
            login-token SP
            reqid EOL 

    returns: OK reqid EOL
    context: local connection 
----


==== Remote Broadcast Final

----
    remote-broadcast-final =
            "REMOTE_BROADCAST_FINAL" SP 
            flogin-token SP 
            reqid EOL 

    returns: OK EOL
    context: local connection
----


==== Encrypt Remote Broadcast Author

----
    encrypt-remote-broadcast-author = 
            %x02 
            flogin-token %x00 
            dist-name %x00 
            generation64 
            recipient-list
            bin16

    returns: OK reqid EOL
    context: user-user message
----


==== Encrypt Remote Broadcast Subject

----
    encrypt-remote-broadcast-subject = 
            %x03 
            hash %x00 
            dist-name %x00 
            generation64 
            recipient-list 
            bin16 

    returns: OK message EOL
    context: user-user message
----


==== Repub Remote Broadcast Publisher

----
    repub-remote-broadcast-publisher = 
            %x04 
            message-id %x00 
            dist-name %x00 
            generation64

    returns OK reqid EOL
    context: user-user message
----


==== Repub Remote Broadcast Author

----
    repub-remote-broadcast-author = 
            %x05 
            message-id %x00 
            dist-name %x00 
            generation64

    returns OK reqid EOL
    context: user-user message
----


==== Repub Remote Broadcast Subject

----
    repub-remote-broadcast-subject = 
            %x06
            message-id %x00
            dist-name %x00
            generation64

    returns OK reqid EOL
    context: user-user message
----


==== Return Remote Broadcast Author

----
    return-remote-broadcast-author =
            %x07
            reqid %x00
            bin16

    returns OK reqid EOL
    context: user-user message
----


==== Return Remote Broadcast Subject

----
    return-remote-broadcast-subject =
            %x08
            reqid %x00
            bin16

    returns OK reqid EOL
    context: user-user message
----


==== Broadcast Success Author

----
    broadcast-success-author =
            %x09
            message-id %x00

    returns OK reqid EOL
    context: user-user message
----


==== Broadcast Success Subject

----
    broadcast-success-subject =
            %x0a
            message-id %x00

    returns OK reqid EOL
    context: user-user message
----


==== Remote Broadcast Key

----
    rb-broadcast-key =
            %x01
            hash 0 
----

== Notifications

The DSNP daemon defers to the content-manager software for tasks that are not
associated with identity, authentication, authorization, encryption, etc. This
includes content that arrives from friends, and various notifications that
result in user experience. Various components require synchronization.

=== Notification Broadcast

----
    broadcast =
            "BROADCAST" SP
            user SP 
            broadcaster SP 
            length EOL body EOL
----

=== Notification Message

----
    message = 
            "MESSAGE" SP
            user SP 
            sender SP 
            length EOL body EOL
----

=== Notification Logout

The logout notification is used by the daemon to indicate to the user agent
that a login session is no longer valid. This should invalidate any cookies
that have been handed out to user. The session ID can be any string of
characters that the user agent wishes to use. It is limited to 48 characters.

----
    logout = 
            "LOGOUT" SP
            session-id EOL
----

=== Notification New User

Indicates that user creation succeeded. The user agent should register the user
in its database.

----
    new-user =
            "NEW_USER" SP
            user EOL
----

=== Friend Request Received

Notification for the responder to the friend request that a new request has
arrived.

----
    friend-request-received =
            "FRIEND_REQUEST_RECEIVED" SP
            user SP
            iduri SP
            hash SP
            accept-reqid EOL
----

=== Friend Request Sent

Notification for the requestor of the relationship that a new request was
successfully sent.

----
    friend-request-sent =
            "FRIEND_REQUEST_SENT" SP
            user SP
            iduri SP
            hash SP
            user-notify-reqid EOL
----

=== Friend Request Accepted

Notification for the responder to the friend request that acceptance succeeded.

----
    friend-request-accepted =
            "FRIEND_REQUEST_ACCEPTED" SP
            user SP
            iduri SP
            accept-reqid EOL
----

=== Sent Friend Request Accepted

Notification for the requestor of the relationship that the request was
accepted.

----
    sent-friend-request-accepted =
            "SENT_FRIEND_REQUEST_ACCEPTED"
            user SP
            iduri SP
            user-notify-reqid EOL
----

== User Messages

User messages are submitted by the user agent to DSNPd, encrypted, distributed
over the network, decrypted, then handed to the receiving user agent for
storage and display. This particular section of DSNP is likely to change, as
better message formats become apparent. For the time being, we use an
rfc822-like message format. There are just four types.

----
publisher-iduri      = "Publisher-Iduri" COLON SP iduri CRLF

author-iduri         = "Author-Iduri" COLON SP iduri CRLF

subject-iduri        = "Subject-Iduri" COLON SP iduri CRLF

message-id           = "Message-Id" COLON SP message-id CRLF

type                 = "Type" COLON SP (
                           "broadcast" /
                           "board-post" /
                           "name-change" /
                           "photo-upload" /
                           "tag"
                        ) CRLF

content-type         = "Content-Type" COLON SP
                           ( "text/plain" / "image/jpg" )

date                 = "Date" COLON SP
                           4digit "-" 2digit "-" 2digit " " 
                           2digit ":" 2digit ":" 2digit CRLF

remote-resource      = "Remote-Resource" COLON SP path CRLF

remote-presentation  = "Remote-Presentation" COLON SP path CRLF
----

=== Broadcast

Broadcast message type is used for so-called status updates.

----
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Content-Type: text/plain
Type: broadcast
Date: YYYY-MM-DD HH:MM:SS

CONTENT
----

=== Board Post

Board post is used for messages that are to be shared with the sender and
recipient's friends. The board post is akin to a "wall" message.

----
Author-Iduri: author-iduri
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Type: board-post
Content-Type: text/plain
Date: YYYY-MM-DD HH:MM:SS

CONTENT
----

=== Name Change

Name change is used to transmit a user's new name.

----
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Type: name-change
Content-Type: text/plain
Date: YYYY-MM-DD HH:MM:SS

CONTENT
----

=== Photo Upload

Photo upload is use to notifiy friend's about a photo that has been uploaded.
Resource-Id is an identifier describing the uploader's image.

----
Publisher-Iduri: publisher-iduri
Type: photo-upload
Message-Id: message-id
Type: name-change
Content-Type: image/jpg
Remote-Resource: /full/path/to/resource
Remote-Presentation: /full/path/to/presentation/page
Date: YYYY-MM-DD HH:MM:SS

CONTENT
----

=== Photo Tag

Photo upload is use to notifiy friend's about a photo that has been uploaded.
Resource-Id is an identifier describing the uploader's image.

----
Author-Iduri: author-iduri
Publisher-Iduri: publisher-iduri
Subject-Iduri: subject-iduri
Type: photo-tag
Message-Id: message-id
Type: name-change
Content-Type: image/jpg
Remote-Resource: /full/path/to/resource
Remote-Presentation: /full//path/to/presentation/page
Date: YYYY-MM-DD HH:MM:SS

CONTENT
----
